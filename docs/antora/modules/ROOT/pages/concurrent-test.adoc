= 多线程并发测试

== 简介

在本教程中，我们将介绍测试并发程序的一些基础知识。我们将主要关注基于线程的并发及其在测试中出现的问题。

我们还将了解如何解决其中的一些问题并在 `Java` 中有效地测试多线程代码。

== 并发编程

并发编程是指将**大量计算分解为较小的、相对独立的**计算的编程。

本练习的目的是并发运行这些较小的计算，甚至可能并行运行。虽然有多种方法可以实现这一点，但目标始终是更快地运行程序。

=== 线程和并发编程

随着处理器比以往任何时候都包装更多的内核，并发编程处于最前沿以有效利用它们。然而，事实仍然是**并发程序的设计、编写、测试和维护要困难得多**。因此，如果我们毕竟可以为并发程序编写有效且自动化的测试用例，我们就可以解决其中的大部分问题。

那么，是什么让为并发代码编写测试变得如此困难？要理解这一点，我们必须了解如何在程序中实现并发。最流行的并发编程技术之一涉及使用线程。

现在，线程可以是本机的，在这种情况下，它们由底层操作系统调度。我们还可以使用所谓的绿色线程，它们由运行时直接调度。

=== 测试并发程序的困难
不管我们使用什么类型的线程，使它们难以使用的是线程通信。如果我们确实设法编写了一个涉及线程但没有线程通信的程序，那就再好不过了！更现实的是，线程通常必须进行通信。有两种方法可以实现这一点——共享内存和消息传递。

**与并发编程相关**的大部分**问题源于使用具有共享内存的本机线程**。出于同样的原因，测试此类程序也很困难。访问共享内存的多个线程通常需要互斥。我们通常通过一些使用锁的保护机制来实现这一点。

但这仍然可能导致一系列问题，例如竞争条件、活锁、死锁和线程饥饿，仅举几例。此外，这些问题是间歇性的，因为在本机线程的情况下线程调度是完全不确定的。

因此，为并发程序编写可以确定性方式检测这些问题的有效测试确实是一个挑战！

=== 线程交错剖析

我们知道原生线程可以被操作系统不可预测地调度。如果这些线程访问和修改共享数据，就会产生有趣的线程交错。虽然其中一些交错可能是完全可以接受的，但其他交错可能会使最终数据处于不希望的状态。

让我们举个例子。假设我们有一个由每个线程递增的全局计数器。在处理结束时，我们希望此计数器的状态与已执行的线程数完全相同：

[source,java]
----
private int counter;
public void increment() {
    counter++;
}
----

现在，在 Java 中增加原始整数不是原子操作。它包括读取值，增加它，最后保存它。当多个线程在做相同的操作时，它可能会产生许多可能的交错：

image::concurrent-test/image-2021-06-02-16-30-42-319.png[]

虽然这种特殊的交织产生了完全可以接受的结果，但这个结果如何：

image::concurrent-test/image-2021-06-02-16-31-10-863.png[]

这不是我们所期望的。现在，想象数百个线程运行比这复杂得多的代码。这将产生难以想象的线程交错方式。

有多种编写代码的方法可以避免此问题，但这不是本教程的主题。使用锁的同步是一种常见的同步，但它存在与竞争条件相关的问题。

3. 测试多线程代码

现在我们了解了测试多线程代码的基本挑战，我们将看看如何克服它们。我们将构建一个简单的用例并尝试模拟尽可能多的与并发相关的问题。

让我们从定义一个简单的类开始，该类记录可能的任何内容：

----
public class MyCounter {
    private int count;
    public void increment() {
        int temp = count;
        count = temp + 1;
    }
    // Getter for count
}
----

这是一段看似无害的代码，但不难理解它不是线程安全的。如果我们碰巧用这个类写一个并发程序，它肯定是有缺陷的。此处测试的目的是识别此类缺陷。

3.1. 测试非并发部分

根据经验，始终建议通过将代码与任何并发行为隔离来测试代码。这是为了合理确定代码中没有其他与并发无关的缺陷。让我们看看如何做到这一点：

----
@Test
public void testCounter() {
    MyCounter counter = new MyCounter();
    for (int i = 0; i < 500; i++) {
        counter.increment();
    }
    assertEquals(500, counter.getCount());
}
----

虽然这里没什么大不了的，但这个测试让我们相信它至少可以在没有并发的情况下工作。

3.2. 并发测试的第一次尝试

让我们继续测试相同的代码，这次是在并发设置中。我们将尝试使用多个线程访问此类的同一个实例，并查看它的行为：

----
@Test
public void testCounterWithConcurrency() throws InterruptedException {
    int numberOfThreads = 10;
    ExecutorService service = Executors.newFixedThreadPool(10);
    CountDownLatch latch = new CountDownLatch(numberOfThreads);
    MyCounter counter = new MyCounter();
    for (int i = 0; i < numberOfThreads; i++) {
        service.execute(() -> {
            counter.increment();
            latch.countDown();
        });
    }
    latch.await();
    assertEquals(numberOfThreads, counter.getCount());
}
----

这个测试是合理的，因为我们试图用多个线程对共享数据进行操作。当我们将线程数保持在较低水平时，例如 10，我们会注意到它几乎一直都在通过。有趣的是，如果我们开始增加线程数，比如增加到 100，我们将看到测试在大多数情况下开始失败。

3.3. 并发测试的更好尝试

虽然之前的测试确实表明我们的代码不是线程安全的，但这个测试存在问题。此测试不是确定性的，因为底层线程以非确定性方式交错。对于我们的程序，我们真的不能依赖这个测试。

我们需要的是一种控制线程交错的方法，这样我们就可以用更少的线程以一种确定性的方式揭示并发问题。我们将从稍微调整我们正在测试的代码开始：

----
public synchronized void increment() throws InterruptedException {
    int temp = count;
    wait(100);
    count = temp + 1;
}
----

在这里，我们使方法同步并在方法内的两个步骤之间引入了等待。的同步关键字确保只有一个线程可以修改计数在一个时间变量，并且等待介绍每个线程执行之间的延迟。

请注意，我们不一定要修改我们打算测试的代码。但是，由于影响线程调度的方法并不多，因此我们采用了这种方法。

在后面的部分中，我们将看到如何在不更改代码的情况下做到这一点。

现在，让我们像之前一样测试这段代码：

----
@Test
public void testSummationWithConcurrency() throws InterruptedException {
    int numberOfThreads = 2;
    ExecutorService service = Executors.newFixedThreadPool(10);
    CountDownLatch latch = new CountDownLatch(numberOfThreads);
    MyCounter counter = new MyCounter();
    for (int i = 0; i < numberOfThreads; i++) {
        service.submit(() -> {
            try {
                counter.increment();
            } catch (InterruptedException e) {
                // Handle exception
            }
            latch.countDown();
        });
    }
    latch.await();
    assertEquals(numberOfThreads, counter.getCount());
}
----

在这里，我们只用两个线程运行它，并且很有可能我们能够得到我们一直遗漏的缺陷。我们在这里所做的是尝试实现特定的线程交错，我们知道这会影响我们。虽然有利于演示，但我们可能会发现这对实际目的没有用。

4. 可用的测试工具

随着线程数量的增加，它们可能交错的方式数量呈指数增长。它只是无法弄清楚所有这些的交错和测试他们。我们必须依靠工具为我们进行相同或类似的工作。幸运的是，有几个可以让我们的生活更轻松。

我们可以使用两大类工具来测试并发代码。第一个使我们能够对具有许多线程的并发代码产生相当高的压力。压力增加了罕见交错的可能性，从而增加了我们发现缺陷的机会。

第二个使我们能够模拟特定的线程交错，从而帮助我们更确定地发现缺陷。


